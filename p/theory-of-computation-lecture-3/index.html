<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Finite Automata"><title>Theory of Computation Lecture 3</title>
<link rel=canonical href=https://suz-tsinghua.github.io/p/theory-of-computation-lecture-3/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="Theory of Computation Lecture 3"><meta property='og:description' content="Finite Automata"><meta property='og:url' content='https://suz-tsinghua.github.io/p/theory-of-computation-lecture-3/'><meta property='og:site_name' content='suz'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Theory of Computation'><meta property='article:published_time' content='2024-04-16T17:00:00+08:00'><meta property='article:modified_time' content='2024-04-16T17:00:00+00:00'><meta property='og:image' content='https://suz-tsinghua.github.io/p/theory-of-computation-lecture-3/cover.png'><meta name=twitter:title content="Theory of Computation Lecture 3"><meta name=twitter:description content="Finite Automata"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://suz-tsinghua.github.io/p/theory-of-computation-lecture-3/cover.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu1189040654346373991.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>😇</span></figure><div class=site-meta><h1 class=site-name><a href=/>suz</a></h1><h2 class=site-description></h2></div></header><ol class=menu-social><li><a href=https://github.com/SUZ-tsinghua target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href='https://scholar.google.com/citations?user=R5Y1xlUAAAAJ&amp;hl=zh-CN&amp;oi=sra' target=_blank title="Google scholar" rel=me><svg class="icon icon-tabler icon-tabler-brand-google" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M20.945 11a9 9 0 11-3.284-5.997l-2.655 2.392A5.5 5.5.0 1017.125 14H13v-3h7.945z"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#deterministic-finite-automaton-dfa>Deterministic Finite Automaton (DFA)</a><ol><li><a href=#dfa-and-regular-languages>DFA and Regular Languages</a></li><li><a href=#regular-languages-are-closed-under-complementation-intersection-and-union>Regular Languages are Closed under Complementation, Intersection and Union</a></li></ol></li><li><a href=#nondeterministic-finite-automaton-nfa>Nondeterministic Finite Automaton (NFA)</a><ol><li><a href=#nfa>NFA</a></li><li><a href=#equivalence-of-nfa-and-dfa>Equivalence of NFA and DFA</a></li><li><a href=#regular-languages-are-closed-under-concatenation-and-star>Regular Languages are Closed under Concatenation and Star</a></li></ol></li><li><a href=#equivalence-of-nfas-dfas-and-regular-expressions>Equivalence of NFAs, DFAs and Regular Expressions</a></li><li><a href=#nonregular-languages>Nonregular Languages</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/theory-of-computation-lecture-3/><img src=/p/theory-of-computation-lecture-3/cover_hu3338406109721622705.png srcset="/p/theory-of-computation-lecture-3/cover_hu3338406109721622705.png 800w, /p/theory-of-computation-lecture-3/cover_hu4938497368424338024.png 1600w" width=800 height=349 loading=lazy alt="Featured image of post Theory of Computation Lecture 3"></a></div><div class=article-details><header class=article-category><a href=/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/>课程笔记</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/theory-of-computation-lecture-3/>Theory of Computation Lecture 3</a></h2><h3 class=article-subtitle>Finite Automata</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 16, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 5 分钟</time></div></footer></div></header><section class=article-content><h1 id=lecture-3-finite-automata>Lecture 3 Finite Automata</h1><p>计算理论剩下的笔记会是 exam-oriented 的，因为系统地写一篇笔记确实太过耗时。</p><h2 id=deterministic-finite-automaton-dfa>Deterministic Finite Automaton (DFA)</h2><h3 id=dfa-and-regular-languages>DFA and Regular Languages</h3><blockquote><p><strong>Definition:</strong></p><p>A <em>DFA</em> is a 5-tuple $(Q, \Sigma, \delta, q, F)$:</p><ul><li>$Q$ is a finite set of states.</li><li>$\Sigma$, the alphabet is a finite set of symbols.</li><li>$\delta: Q\times \Sigma \to Q$ is the transition function.</li><li>$q\in Q$ is the start state.</li><li>$F\subset Q$ is the set of accepting states.</li></ul></blockquote><p>DFA 做的事情就是从 start state 开始，每次从输出序列中获取下一个 symbol，依据 transition function 转成另一个state，直到 inputs 被获取完，判断此时的 state 是否为 accepting state。</p><blockquote><p><strong>Definition:</strong></p><p>A DFA $M$ <em>accepts</em> the input $w$ if:</p><ul><li>$M=(Q,\Sigma,\delta,q,F)$.</li><li>$w=w_1 w_2\cdots w_n$, each $w_i\in \Sigma$ for $1\leq i\leq n$.</li><li>$\exists (r_0, r_1, \cdots, r_n)$, each $r_i\in Q$ for $0\leq i\leq n$ s.t.</li><li><ul><li>$r_0 = q$, the start state.</li></ul></li><li><ul><li>$r_i = \delta (r_{i-1}, w_i)$, for $1\leq i\leq n$.</li></ul></li><li><ul><li>$r_n\in F$.</li></ul></li></ul></blockquote><p>每个 DFA 都存在一些 inputs 的集合，使其 accepts，定义这个集合为 DFA 的 language。</p><blockquote><p><strong>Definition:</strong></p><p>A <em>Language</em> is a (possibly infinite) set of strings over some alphabet.</p><p>$L(M) = \{w | M \text{ accepts } w\}$ is the language <em>recognized</em> by M.</p></blockquote><p>A DFA always recognizes one language!</p><p>If it accepts no strings, it recognize the “empty language” $\emptyset$.</p><p>DFA 可以做一些简单的任务，比如判断一个 binary number 是否可以被 3 整除（只需要用 states 存目前被 3 除的余数即可），比如判断一个字母序列是否包含 b（检测到 b 就进入 accepting state）。由此我们可以定义 regular languages：</p><blockquote><p><strong>Definition:</strong></p><p><em>Regular languages</em> is the set of all languages recognized by some DFA.</p></blockquote><p>所以只要一个 language 能被某个 DFA 识别，那它就是一个 regular language。</p><h3 id=regular-languages-are-closed-under-complementation-intersection-and-union>Regular Languages are Closed under Complementation, Intersection and Union</h3><p>对于一个或几个 regular language(s)，我们可以由它们构造新的 language，使得新的 language 也是 regular language。比如 complementation: $L^{\prime}=\bar{L}$. 即我们现在已知存在某个 DFA $M$ 使得 $L=L(M)$, 我们是否能找到一个 DFA $M^{\prime}$ 使得 $L(M^{\prime})=\bar(L(M))$。</p><blockquote><p><strong>Theorem:</strong></p><p>The class of regular languages is closed under complementation.</p><p><strong>Proof:</strong></p><p>根据 $M$, 构造一新的 DFA $M^{\prime}$，二者完全一样，除了 $M^{\prime}$ 的 accepting states 是 $M$ 的 accepting states 的补集。这样的话一个 input 能被 $M$ 识别当且仅当其不能被 $M^{\prime}$ 识别。</p></blockquote><blockquote><p><strong>Theorem:</strong></p><p>The class of regular languages is closed under intersection.</p><p><strong>Proof:</strong></p><p>假设我们现在有两个 DFAs $M_1=(Q_1, \Sigma, \delta_1, s_1, F_1), M_2=(Q_2, \Sigma, \delta_2, s_2, F_2)$，构造一新 DFA $M_3=(Q_1\times Q_2, \Sigma, \delta_1\times \delta_2, (s_1,s_2), F_3)$。即 $M_3$ 的状态空间是 $Q_1$ 和 $Q_2$ 的直积，在两个分量空间中分别作 transition。$(q_1, q_2)\in F_3$ 当且仅当 $q_1\in F_1, q_2\in F_2$。</p></blockquote><blockquote><p><strong>Theorem:</strong></p><p>The class of regular languages is closed under uniton.</p><p><strong>Proof:</strong></p><p>可以用 DeMorgan’s Law $X\cup Y = \overline{(\bar{X}\cap\bar{Y})}$，也可以用与上一 theorem 类似的构造。</p></blockquote><p>定义 regular operations on languages:</p><blockquote><p><strong>Definition:</strong>
A & B are two (possibly infinite) sets of strings. Define regular operations on them:</p><ul><li>Union: $A \cup B = \{x | x\in A \text{ or } x\in B\}$.</li><li>Concatenation: $A\circ B = \{xy | x\in A \text{ and } y\in B\}$.</li><li>Star: $A^* = \{x_1 x_2 \cdots x_k | k\geq 0 \text{ and all } x_i\in A\}$.</li><li><ul><li>note: the empty string $\epsilon (k=0)$ is always in $A^*$.</li></ul></li></ul></blockquote><p>我们已知 regular languages is closed under union，但对剩下两种 operations，很难直接构造出合适的 DFA，需要先引入新的概念。</p><h2 id=nondeterministic-finite-automaton-nfa>Nondeterministic Finite Automaton (NFA)</h2><h3 id=nfa>NFA</h3><p>NFA 与 DFA 类似，但它</p><ul><li>可以不获取输入自发转变状态（也可以被视作获取空字符 $\epsilon$）。</li><li>在某个状态获取某个输入之后，转变成的新状态有很多种可能。</li></ul><blockquote><p><strong>Definition:</strong></p><p>An <em>NFA</em> is a 5-tuple $(Q, \Sigma, \delta, q, F)$:</p><ul><li>$Q$ is a finite set of states.</li><li>$\Sigma$, the alphabet is a finite set of symbols.</li><li>$\delta: Q\times \Sigma_{\epsilon} \to 2^Q$ is the transition function.</li><li>$q\in Q$ is the start state.</li><li>$F\subset Q$ is the set of accepting states.</li></ul><p>这里，$\Sigma_{\epsilon}=\Sigma\cup\{\epsilon\}$，$2^Q$ 是 $Q$ 的所有子集组成的集合，叫做 $Q$ 的 power set。</p></blockquote><blockquote><p><strong>Definition:</strong></p><p>An NFA $N$ <em>accepts</em> the input $w\in \Sigma^*$ if:</p><ul><li>$N=(Q,\Sigma,\delta,q,F)$.</li><li>$w$ can be written as $x_1 x_2\cdots x_n$, each $x_i\in \Sigma_{\epsilon}$ for $1\leq i\leq n$.</li><li><ul><li>注意这里用的是 &ldquo;can be written&rdquo; 而不是 &ldquo;="，因为 $&ldquo;abba&rdquo;$ can be written as $&ldquo;a\epsilon bb \epsilon a&rdquo;$。</li></ul></li><li>$\exists (r_0, r_1, \cdots, r_n)$, each $r_i\in Q$ for $0\leq i\leq n$ s.t.</li><li><ul><li>$r_0 = q$, the start state.</li></ul></li><li><ul><li>$r_i \in \delta (r_{i-1}, x_i)$, for $1\leq i\leq n$.</li></ul></li><li><ul><li>$r_n\in F$.</li></ul></li></ul></blockquote><h3 id=equivalence-of-nfa-and-dfa>Equivalence of NFA and DFA</h3><p>可以证明 NFA 与 DFA 是等价的，即对任意 NFA 都可以找到一个 DFA，使得二者的 language 相同；对任意 DFA 也可以找到一个 NFA，使得二者的 language 相同。后者是显然的，因为任意 DFA 本身就可以被视为一个 NFA。我们现在要证明前者。</p><blockquote><p><strong>Theorem:</strong></p><p>For any NFA $N$, there is a DFA $M$ such that $L(N) = L(M)$.</p><p><strong>Proof:</strong></p><p>总的思想就是：at all times, M keeps track of the set of states that N could be in.</p><p>(1) 先对 $N$ 中不存在 $\epsilon$ 的情况证明：</p><p>若 $N=(Q,\Sigma,\delta,q,F)$，令 $M=(Q^{\prime}, \Sigma, \delta^{\prime}, q^{\prime}, F^{\prime})$:</p><ul><li>$Q^{\prime}=2^{Q}$</li><li>$\delta^{\prime}(R,a)=\cup_{r\in R}\delta(r,a)$。其中 $R\in 2^{Q}, a\in \Sigma$。</li><li>$q^{\prime}=\{q\}$</li><li>$F^{\prime}=\{R\in Q^{\prime} | R\cap F\neq \emptyset\}$</li></ul><p>(2) 对于存在 $\epsilon$ 的情况，可以将 $\epsilon$ 后的 state 并入前面的 state。Formally:</p><p>令 $E(R)=\{r\in Q | r \text{ is reachable from } R \text{ using zero on more } \epsilon \text{-transitions}\}$.</p><ul><li>$Q^{\prime}=2^{Q}$</li><li>$\delta^{\prime}(R,a)=\cup_{r\in R}E(\delta(r,a))$。其中 $R\in 2^{Q}, a\in \Sigma$。</li><li>$q^{\prime}=E(\{q\})$</li><li>$F^{\prime}=\{R\in Q^{\prime} | R\cap F\neq \emptyset\}$</li></ul></blockquote><p>一个 NFA 需要 $\log_2 |Q|$ bits 来存 states，与其等价的 DFA 需要 $\log_2 |Q^{\prime}| = |Q|$ bits 来存 states。可以举出一个 NFA 的例子，证明这样的 exponential blowup 在某些情况下是必须的。</p><blockquote><p><strong>Example:</strong></p><p>$\Sigma=\{a,b\}, L_k=\{w\in\{a,b\}^* | \text{ the } k \text{-th symbol from the end is } b\}$. There is a $(k+1)$-state NFA recognizing $L_k$.</p><p><img src=/p/theory-of-computation-lecture-3/1.png width=1284 height=233 srcset="/p/theory-of-computation-lecture-3/1_hu12285616191936858880.png 480w, /p/theory-of-computation-lecture-3/1_hu10540943677457612510.png 1024w" loading=lazy class=gallery-image data-flex-grow=551 data-flex-basis=1322px></p><p>Then we prove that any DFA with $&lt; 2^k$ states can not recognize $L_k$.</p><p>We prove by contradiction.</p><p>(1) Assume there is a DFA $M$ with $|Q| = 2^k - 1$.</p><p>(2) Imagine running $M$ on each input $w\in\{a,b\}^k$.</p><p>(3) By the pigeonhole principle, $\exists w \neq w^{\prime}\in\{a,b\}^k$ s.t. after reading $w$ and $w^{\prime}$, $M$ is in the same state.</p><p>(4) Let $j+1$ be the first position where $w$ and $w^{\prime}$ differ.</p><p>(5) Run $M$ on $wa^j$ and $w^{\prime}a^j$. $M$ is supposed to be in the same state. But $w\notin L_k, w^{\prime}\in L_k$. A contradiction.</p><p><img src=/p/theory-of-computation-lecture-3/2.png width=1138 height=220 srcset="/p/theory-of-computation-lecture-3/2_hu7648609160853684226.png 480w, /p/theory-of-computation-lecture-3/2_hu8192488999227300051.png 1024w" loading=lazy class=gallery-image data-flex-grow=517 data-flex-basis=1241px></p></blockquote><h3 id=regular-languages-are-closed-under-concatenation-and-star>Regular Languages are Closed under Concatenation and Star</h3><p>先介绍定理：</p><blockquote><p><strong>Theorem:</strong></p><p>For any NFA $N_1$, there is an NFA $N_2$ such that $L(N_1) = L(N_2)$ and $N_2$ has exactly one accept state.</p><p><strong>Proof:</strong></p><p>把 $N_1$ 中所有的 accepting states 用 $\epsilon$ 连到一个新的 accepting states。</p></blockquote><blockquote><p><strong>Theorem:</strong></p><p>The class of regular languages is closed under concatenation.</p><p><strong>Proof:</strong></p><p>对于 $N_1, N_2$ 构造 $N_3$ 使得 $L(N_3)=L(N_1)\circ L(N_2)$。只需要把 $N_1$ 的 accepting states 都用 $\epsilon$ 连到 $N_2$ 的 starting state 就行。</p></blockquote><blockquote><p><strong>Theorem:</strong></p><p>The class of regular languages is closed under star。</p><p><strong>Proof:</strong></p><p>如下图构造 $L(N_2)=L(N_1)^*$:</p><p><img src=/p/theory-of-computation-lecture-3/3.png width=1055 height=516 srcset="/p/theory-of-computation-lecture-3/3_hu4782533735029558264.png 480w, /p/theory-of-computation-lecture-3/3_hu11922664207413084886.png 1024w" loading=lazy class=gallery-image data-flex-grow=204 data-flex-basis=490px></p></blockquote><h2 id=equivalence-of-nfas-dfas-and-regular-expressions>Equivalence of NFAs, DFAs and Regular Expressions</h2><blockquote><p><strong>Definition:</strong></p><p>一个 <em>regular expression (REGEXP)</em> 是用以下方式表示的一个集合：
从 $\{a\}, \{\epsilon\}, \emptyset$ 开始，通过 $(R_1\cup R_2), (R_1\circ R_2), (R_1^*)$ 构成。</p><p>简化：省略 $\circ$，定义计算顺序 $^*, \circ, \cup$。</p></blockquote><p>接下来证明 REGEXP 和 NFA 等价。</p><blockquote><p><strong>Theorem:</strong></p><p>(1) The language of any REGEXP is recognized by an NFA.</p><p>(2) The language of any NFA can be represented by a REGEXP.</p></blockquote><p>(1) 是显然的，因为 regular languages are closed under $\cup, \circ, ^*$。</p><p>(2) 不显然，需要引入新概念。</p><blockquote><p><strong>Definition:</strong></p><p>A <em>GNFA (Generalized NFA)</em> is a 5-tuple $(Q, \Sigma, \delta, q_{start}, q_{accept})$:</p><ul><li>$Q$ is a finite set of states.</li><li>$\Sigma$, the alphabet is a finite set of symbols.</li><li>$q_{start}$ is the start state.</li><li>$q_{accept}$ is the accept state.</li><li>$\delta: (Q\backslash \{q_{accept}\}) \times (Q\backslash \{q_{start}\}) \to REGEXP$ is the transition function.</li></ul></blockquote><p>简单地说，GNFA 就是 NFA，只不过 transition 用 REGEXP 表达。显然 GNFA 和 NFA 等价。</p><p>故而，证明 (2) 的思路为：任意一个 NFA 都可以用一个 GNFA 表示，任意一个 GNFA 都可以被缩减为只有两个 states，所以等价于一个 REGEXP。第一步和第三步显然。第二步逐个删去 state 即可，图解：</p><p><img src=/p/theory-of-computation-lecture-3/4.png width=1101 height=376 srcset="/p/theory-of-computation-lecture-3/4_hu17395546765287011142.png 480w, /p/theory-of-computation-lecture-3/4_hu15323961194027872921.png 1024w" loading=lazy class=gallery-image data-flex-grow=292 data-flex-basis=702px></p><h2 id=nonregular-languages>Nonregular Languages</h2><blockquote><p><strong>Example:</strong></p><p>\{0^n 1^n|n\geq 0\} is nonregular.</p><p><strong>Proof:</strong></p><p>Assume it&rsquo;s regular, the DFA recognizing it consists of $p$ states. Then by the pigeonhole principle, there exists $i,j$ such that after reading $0^i, 0^j$, the DFA is in the same state. So if it accepts $0^i 1^i$, it must accept $0^j 1^i$, which is a contradiction.</p></blockquote><p>用这种思想，可以引入 pumping lemma:</p><blockquote><p><strong>Pumping Lemma:</strong></p><p>If $A$ is a regular language, then there is a number $p$ (the pumping length) where, if $s$ is any string in $A$ of length at least $p$, then $s$ can be divided into $s=xyz$, satisfying:</p><ul><li>For each $i\geq 0, xy^i z \in A$</li><li>$|y|>0$</li><li>$|xy|\leq p$</li></ul><p><strong>Proof:</strong></p><p>令 $p$ 是 DFA 的状态数，再用上面那个例子中类似的思想即可。</p></blockquote><p>可以用 pumping lemma 判断 nonregular language。如果不满足 pumping lemma，那么肯定是 nonregular language。思路就是，假设有个 $p$，再从 language 中找反例。</p><p>可以证明 $\{ww|w\in \{0,1\}^*\}, \{1^{n^2}|n\geq 0\}, \{0^i 1^j|i>j\}$ 都是 nonregular language。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/theory-of-computation/>Theory of Computation</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Apr 16, 2024 17:00 UTC</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/theory-of-computation-lecture-4/><div class=article-image><img src=/p/theory-of-computation-lecture-4/cover.5a4cd64d97d6d054c8c5b7c90f52a40a_hu6720720966422977467.png width=250 height=150 loading=lazy alt="Featured image of post Theory of Computation Lecture 4" data-key=Theory-of-Computation-Lecture-4 data-hash="md5-WkzWTZfW0FTIxbfJD1KkCg=="></div><div class=article-details><h2 class=article-title>Theory of Computation Lecture 4</h2></div></a></article><article class=has-image><a href=/p/theory-of-computation-lecture-2/><div class=article-image><img src=/p/theory-of-computation-lecture-2/cover.d961239af205931394d8a84ce64bd2a7_hu6011312951006749613.png width=250 height=150 loading=lazy alt="Featured image of post Theory of Computation Lecture 2" data-key=Theory-of-Computation-Lecture-2 data-hash="md5-2WEjmvIFkxOU2KhM5kvSpw=="></div><div class=article-details><h2 class=article-title>Theory of Computation Lecture 2</h2></div></a></article><article class=has-image><a href=/p/theory-of-computation-lecture-1/><div class=article-image><img src=/p/theory-of-computation-lecture-1/cover.86b4cdeb0eca4d88890d85ec894e304c_hu14731684250797830019.png width=250 height=150 loading=lazy alt="Featured image of post Theory of Computation Lecture 1" data-key=Theory-of-Computation-Lecture-1 data-hash="md5-hrTN6w7KTYiJDYXsiU4wTA=="></div><div class=article-details><h2 class=article-title>Theory of Computation Lecture 1</h2></div></a></article><article><a href=/p/drl-notes-6/><div class=article-details><h2 class=article-title>Deep Reinforcement Learning Lecture 6</h2></div></a></article><article><a href=/p/drl-notes-5/><div class=article-details><h2 class=article-title>Deep Reinforcement Learning Lecture 5</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=SUZ-tsinghua/SUZ-tsinghua.github.io issue-term=title crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2024 suz</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>