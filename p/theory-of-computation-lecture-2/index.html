<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Mathematical Logic (2)"><title>Theory of Computation Lecture 2</title>
<link rel=canonical href=https://suz-tsinghua.github.io/p/theory-of-computation-lecture-2/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="Theory of Computation Lecture 2"><meta property='og:description' content="Mathematical Logic (2)"><meta property='og:url' content='https://suz-tsinghua.github.io/p/theory-of-computation-lecture-2/'><meta property='og:site_name' content='suz'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Theory of Computation'><meta property='article:published_time' content='2024-04-02T17:00:00+08:00'><meta property='article:modified_time' content='2024-04-02T17:00:00+00:00'><meta property='og:image' content='https://suz-tsinghua.github.io/p/theory-of-computation-lecture-2/cover.png'><meta name=twitter:title content="Theory of Computation Lecture 2"><meta name=twitter:description content="Mathematical Logic (2)"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://suz-tsinghua.github.io/p/theory-of-computation-lecture-2/cover.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu1189040654346373991.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>😇</span></figure><div class=site-meta><h1 class=site-name><a href=/>suz</a></h1><h2 class=site-description></h2></div></header><ol class=menu-social><li><a href=https://github.com/SUZ-tsinghua target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href='https://scholar.google.com/citations?user=R5Y1xlUAAAAJ&amp;hl=zh-CN&amp;oi=sra' target=_blank title="Google scholar" rel=me><svg class="icon icon-tabler icon-tabler-brand-google" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M20.945 11a9 9 0 11-3.284-5.997l-2.655 2.392A5.5 5.5.0 1017.125 14H13v-3h7.945z"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#informal-predicate-calculus-非形式的谓词演算>Informal Predicate Calculus (非形式的谓词演算)</a><ol><li><a href=#量词>量词</a></li><li><a href=#一阶语言>一阶语言</a></li><li><a href=#解释>解释</a></li><li><a href=#满足真>满足，真</a></li></ol></li><li><a href=#formal-predicate-calculus-形式的谓词演算>Formal Predicate Calculus (形式的谓词演算)</a><ol><li><a href=#形式系统-k_mathscrl>形式系统 $K_{\mathscr{L}}$</a></li><li><a href=#前束范式>前束范式</a></li><li><a href=#k_mathscrl-的完备性定理>$K_{\mathscr{L}}$ 的完备性定理</a></li><li><a href=#模型>模型</a></li></ol></li><li><a href=#数学系统>数学系统</a><ol><li><a href=#一阶算术>一阶算术</a></li></ol></li><li><a href=#gödel-incompleteness-theorem-哥德尔不完全性定理>Gödel incompleteness theorem (哥德尔不完全性定理)</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/theory-of-computation-lecture-2/><img src=/p/theory-of-computation-lecture-2/cover_hu18262443176209930262.png srcset="/p/theory-of-computation-lecture-2/cover_hu18262443176209930262.png 800w, /p/theory-of-computation-lecture-2/cover_hu6245516989338492298.png 1600w" width=800 height=221 loading=lazy alt="Featured image of post Theory of Computation Lecture 2"></a></div><div class=article-details><header class=article-category><a href=/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/>课程笔记</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/theory-of-computation-lecture-2/>Theory of Computation Lecture 2</a></h2><h3 class=article-subtitle>Mathematical Logic (2)</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 02, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 10 分钟</time></div></footer></div></header><section class=article-content><h1 id=lecture-2-mathematical-logic-2>Lecture 2 Mathematical Logic (2)</h1><h2 id=informal-predicate-calculus-非形式的谓词演算>Informal Predicate Calculus (非形式的谓词演算)</h2><h3 id=量词>量词</h3><p>对于某些命题，我们无法用第一节课中的方式将其表达为一命题形式，如“所有人都会死”，此时我们必须要引入量词来表达“所有”这样的限制语义：</p><blockquote><p><strong>Definition:</strong></p><p><em>全称量词 (Universal quantifier)</em>，对所有的 $x$，$(\forall x)$。</p><p><em>存在量词 (Existensial quantifier)</em>，存在 $x$，$(\exists x)$。</p></blockquote><p>“所有人都会死”就可以表示成 $(\forall x)(A(x)\to M(x))$。
此处，$x$ 为一变元，指的是所有的东西，并不只限于人。$A(x)$ 表示 $x$ 是人，$M(x)$ 表示 $x$ 会死。</p><p>$\forall$ 和 $\exists$ 之间也可以相互转换。考察句子“不是所有鸟都会飞”，可以表示为 $\sim(\forall x)(B(x)\to F(x))$。句子显然等价于“有些鸟不会飞”，可以表示为 $(\exists x)(B(x)\land \sim F(x))$。</p><p>我们知道：</p><p>$$
\begin{align*}
\sim(\forall x)(B(x)\to F(x)) &\iff \sim(\forall x)(\sim B(x)\lor F(x))\\
& \iff \sim(\forall x)\sim (B(x)\land \sim F(x))
\end{align*}
$$</p><p>对比 $\sim(\forall x)\sim (B(x)\land \sim F(x))$ 与 $(\exists x)(B(x)\land \sim F(x))$，不难发现二者有相似之处。事实上，$(\exists x)\mathscr{A} \iff \sim(\forall x)\sim \mathscr{A}$。</p><h3 id=一阶语言>一阶语言</h3><p>在引入量词的基础上，我们希望跟第一讲中一样，构造一形式系统。我们称之为 <em>一阶语言 (first order language)</em>。按照第一讲中定义，形式系统由符号库、合式公式、公理、演绎规则组成。先考察前二者。</p><p>The alphabet of symbols:</p><div class=table-wrapper><table><thead><tr><th>Names</th><th>Symbols</th></tr></thead><tbody><tr><td>变元</td><td>$x_1, x_2, \cdots$</td></tr><tr><td>某些（可能没有）个体常元</td><td>$a_1, a_2, \cdots$</td></tr><tr><td>某些（可能没有）谓词字母</td><td>$A_i^n$</td></tr><tr><td>某些（可能没有）函数字母</td><td>$f_i^n$</td></tr><tr><td>标点符号</td><td>( ) ,</td></tr><tr><td>联结词</td><td>$\sim$ $\to$</td></tr><tr><td>量词</td><td>$\forall$</td></tr></tbody></table></div><p>其中，个体常元即为一个特殊的个体，如“苏格拉底”这样一个指定的人。谓词类似一种关系 $R$，可以被视为一个函数，获取 $n$ 个输入，并返回 $T$ 或 $F$。由于 $\exists$ 可以转化为 $\forall$，我们在符号库中仅使用 $\forall$。</p><p>例如：$(\forall x_1)(\forall x_2) A_1^2(f_1^2(x_1,x_2), f_1^2(x_2,x_1))$，若 $A_1^2$ 表示 $=$，$f_1^2$ 表示 $+$，那整个命题就可以写成 $(\forall x_1)(\forall x_2) (x_1+x_2=x_2+x_1)$。</p><p>接下来定义合式公式：</p><blockquote><p><strong>Definition:</strong></p><p>令 $\mathscr{L}$ 是一阶语言，$\mathscr{L}$ 中的一个 <em>项 (term)</em> 定义如下：</p><ul><li>变元和个体常元是项。</li><li>如果 $t_1, \cdots, t_n$ 是项，那么 $f_i^n(t_1,\cdots,t_n)$ 是项。</li><li>所有项都由上两条规则生成。</li></ul><p>若 $t_1, \cdots, t_k$ 是 $\mathscr{L}$ 中的项，那么 $A_i^k(t_1, \cdots, t_k)$ 是 $\mathscr{L}$ 中的一个 <em>原子公式 (atomic fomula)</em>。</p><p>$\mathscr{L}$ 中的 <em>合式公式 (well-formed formula)</em> 定义为：</p><ul><li>每个原子公式是一个合式公式。</li><li>若 $\mathscr{A}, \mathscr{B}$ 是合式公式，那么 $(\sim \mathscr{A}), (\mathscr{A}\to\mathscr{B})$ 和 $(\forall x_i)\mathscr{A}$ （其中 $x_i$ 是任何变元）也是 $\mathscr{L}$ 中的合式公式。</li><li>所有合式公式都由上两条规则生成。</li></ul></blockquote><p>我们应注意到 $(\forall x_1)(\mathscr{A}\to\mathscr{B})$ 与 $((\forall x_1)\mathscr{A}\to\mathscr{B})$ 表达的是不同的东西，故而需要引入下面的定义。</p><blockquote><p><strong>Definition:</strong></p><p>在公式 $(\forall x_i)\mathscr{A}$ 中，我们称 $\mathscr{A}$ 是量词的 <em>辖域 (scope)</em>。</p><p>变元 $x_i$ 如果出现在 $(\forall x_i)$ 的辖域中，则称它是 <em>约束的 (bound)</em>，反之称它是 <em>自由的 (free)</em>。</p></blockquote><p>例如 $(\forall \textcolor{red}{x_1})(A_1^2(\textcolor{red}{x_1},x_2)\to (\forall \textcolor{red}{x_2})A_1^1(\textcolor{red}{x_2}))$ 中，标红的即为约束的变元。</p><p>现考察变元的替换，在公式 $(\exists x_2)(x_2=x_1(x_1+1))$ 中，我们可以将 $x_1$ 换成 $x_3, f(x_1, x_3)$ 等不包含 $x_2$ 的项，但显然不能换成 $f(x_1, x_2)$ 这种包含 $x_2$ 的项。引入以下定义：</p><blockquote><p><strong>Definition:</strong></p><p>令 $\mathscr{A}$ 是 $\mathscr{L}$ 中的任何公式，我们称项 $t$ 对 $\mathscr{A}$ 中的 $x_i$ 是自由的，如果 $x_i$ 并不自由地出现在 $\mathscr{A}$ 的一个 $(\forall x_j)$ 的辖域中，这里 $x_j$ 是出现在 $t$ 中的任何变元。</p></blockquote><p>在上面的例子中，$t=f(x_1,x_2), x_i=x_1, x_j=x_2$，$x_1$ 自由地出现在 $\mathscr{A}$ 中 $x_2$ 的辖域中，故 $f(x_1,x_2)$ 对 $(\exists x_2)(x_2=x_1(x_1+1))$ 中的 $x_1$ 不是自由的。</p><p>显然，对任何 $x_1$ 和 $\mathscr{A}$ 来说，$x_1$ 对 $\mathscr{A}$ 中的 $x_1$ 都是自由的。</p><h3 id=解释>解释</h3><p>我们现在希望考察 $\mathscr{L}$ 中的公式什么时候能被称为是 “真” 的。事实上，只有当公式中内容的 “解释” 被给出的时候，我们才能讨论公式的真假。</p><p>例如， $(\forall x_1)(\forall x_2)A_1^2(f_1^2(x_1,x_2), f_1^2(x_2,x_1))$。如果我们在自然数的范围内讨论，且认为 $A_1^2$ 代表 $=$，$f_1^2$ 代表 $+$，那么公式为真。但倘若 $f_1^2$ 代表 $-$，那么公式显然是假的。</p><blockquote><p><strong>Definition:</strong></p><p>$\mathscr{L}$ 中的一个 <em>解释 (interpretation)</em> $I$ 由以下四部分组成：</p><ul><li>一个非空集合 $D_I$，即 $I$ 的 <em>论域 (domain)</em>。</li><li>一个 <em>特异元素集 (a collection of distinguished elements)</em> $\bar{a}_i\in D_I$。</li><li>一个在 $D_I$ 上的函数集 $\bar{f}_i^n: D_I^n\to D_I$。</li><li>一个在 $D_I$ 上的关系集 $\bar{A}_i^n$。</li></ul></blockquote><p>四者分别是对符号表中变元，个体常元，函数字母，谓词字母的具体解释。</p><p>例如可以取 $D_I=\{0,1,2,\cdots\}, a_1=0, A_1^2$ 表示 $=$, $f_1^2$ 表示 $+$。那么在 $I$ 中，$(\forall x_1) A_1^2(f_1^2(x_1, a_1), x_1)$ 为真。</p><h3 id=满足真>满足，真</h3><blockquote><p><strong>Definition:</strong></p><p>$I$ 上的一个 <em>赋值 (valuation)</em> 是一从 $\mathscr{L}$ 的项集到集合 $D_I$ 的具有下列性质的一个函数 $v$:</p><ul><li>$v(a_i)=\bar{a}_i$，对 $\mathscr{L}$ 中的每个个体常元 $a_i$。</li><li>$v(f_i^n(t_1,t_2,\cdots, t_n)) = \bar{f}_i^n(v(t_1), v(t_2), \cdots, v(t_n))$，其中 $f_i^n$ 是 $\mathscr{L}$ 中的任意函数字母，$t_1, \cdots, t_n$ 是 $\mathscr{L}$ 中的任意项。</li></ul></blockquote><p>接下来我们要讨论一个赋值能够使得公式为真。</p><blockquote><p><strong>Definition:</strong></p><p>两个赋值 $v, v^{\prime}$，如果对每个 $j\neq i$，都有 $v(x_j)=v^{\prime}(x_j)$，则称二者是 $i$-等值的。</p></blockquote><blockquote><p><strong>Definition:</strong></p><p>令 $\mathscr{A}$ 是 $\mathscr{L}$ 的一个公式，$I$ 是 $\mathscr{L}$ 的一个解释，我们称 $I$ 中的一个赋值 $v$ <em>满足 (satisfies)</em> $\mathscr{A}$，如果能按如下四个条件归纳地表明 $v$ 满足 $\mathscr{A}$:</p><ul><li>如果 $\bar{A}_j^n(v(t_1), \cdots, v(t_n))$ 在 $D_I$ 中为真，那么称 $v$ 满足原子公式 $A_j^n(t_1, \cdots, t_n)$。</li><li>如果 $v$ 不满足 $\mathscr{B}$，那么 $v$ 满足 $(\sim\mathscr{B})$。</li><li>如果 $v$ 满足 $(\sim \mathscr{B})$ 或 $\mathscr{C}$，那么 $v$ 满足 $(\mathscr{B}\to\mathscr{C})$。</li><li>如果每个 $i$-等值于 $v$ 的赋值 $v^{\prime}$ 都满足 $\mathscr{B}$，那么 $v$ 满足 $(\forall x_i)\mathscr{B}$。</li></ul></blockquote><blockquote><p><strong>Definition:</strong></p><ul><li>一公式 $\mathscr{A}$ 在解释 $I$ 中称为 <em>真的 (true)</em>，如果在 $I$ 中的每个赋值都满足 $\mathscr{A}$。</li><li>一公式 $\mathscr{A}$ 在解释 $I$ 中称为 <em>假的 (false)</em>，如果 $I$ 中不存在任何满足 $\mathscr{A}$ 的赋值。</li></ul></blockquote><p>在 <em>真</em> 的基础上更近一步：</p><blockquote><p><strong>Definition:</strong></p><ul><li>$\mathscr{L}$ 的一个合式公式 $\mathscr{A}$ 称为 <em>逻辑有效的 (logically valid)</em>，如果 $\mathscr{A}$ 在 $\mathscr{L}$ 中的每个解释都为真。</li><li>$\mathscr{L}$ 的一个合式公式 $\mathscr{A}$ 称为 <em>矛盾的 (contradictory)</em>，如果 $\mathscr{A}$ 在 $\mathscr{L}$ 中的每个解释都为假。</li></ul></blockquote><blockquote><p><strong>Proposition:</strong></p><p>如果在一个解释中，公式 $\mathscr{A}$ 和 $(\mathscr{A}\to\mathscr{B})$ 都为真，那么 $\mathscr{B}$ 也为真。</p><p><strong>Proof:</strong>
由真和赋值的定义即可证明。</p></blockquote><blockquote><p><strong>Proposition:</strong></p><p>在一个解释中，公式 $\mathscr{A}$ 为真，当且仅当 $(\forall x_i) \mathscr{A}$ 为真，其中 $x_i$ 是任意变元。</p><p><strong>Proof:</strong>
由定义。</p></blockquote><p>例如可以取 $D_I=\{0,1,2,\cdots\}, A_1^2$ 表示 $=$, $f_1^2$ 表示 $+$。那么
$$(\forall x_1)(\forall x_2) A_1^2(f_1^2(x_1,x_2),f_1^2(x_2,x_1))$$
$$(\forall x_2) A_1^2(f_1^2(x_1,x_2),f_1^2(x_2,x_1))$$
$$A_1^2(f_1^2(x_1,x_2),f_1^2(x_2,x_1))$$
都为真。</p><blockquote><p><strong>Definition:</strong></p><p>$\mathscr{L}$ 中的一个公式 $\mathscr{A}$ 称为 <em>闭的 (closed)</em>，如果没有变元在 $\mathscr{A}$ 中自由出现。</p></blockquote><p>例如，$(\forall x_1)(\forall x_2) A_1^2(f_1^2(x_1,x_2),f_1^2(x_2,x_1))$ 是闭的，$(\forall x_1) A_1^1(x_1)\to A_1^1(x_1)$ 不是闭的。</p><blockquote><p><strong>Proposition:</strong></p><p>如果 $\mathscr{A}$ 是 $\mathscr{L}$ 中的闭公式，且 $I$ 是 $\mathscr{L}$ 的一个解释，那么 $\mathscr{A}$ 在 $I$ 中非真即假。</p><p><strong>Proof:</strong></p><p>由于所有变量都是约束的，所以可以根据 <em>满足</em> 的定义的第四条得知，一个赋值满足 $\mathscr{A}$ 当且仅当所有赋值满足 $\mathscr{A}$。</p></blockquote><h2 id=formal-predicate-calculus-形式的谓词演算>Formal Predicate Calculus (形式的谓词演算)</h2><h3 id=形式系统-k_mathscrl>形式系统 $K_{\mathscr{L}}$</h3><p>在 <a class=link href=#%e4%b8%80%e9%98%b6%e8%af%ad%e8%a8%80># 一阶语言</a> 中我们说到，形式系统需由符号库、合式公式、公理、演绎规则组成，并定义了前二者。接下来我们定义后二者，并由此得到一个形式系统 $K_{\mathscr{L}}$。</p><blockquote><p><strong>Definition:</strong></p><p>令 $\mathscr{A},\mathscr{B},\mathscr{C}$ 是 $\mathscr{L}$ 中的任意公式，以下是 $K_{\mathscr{L}}$ 的公理：</p><ul><li>(K1) $(\mathscr{A}\to(\mathscr{B}\to\mathscr{A}))$.</li><li>(K2) $((\mathscr{A}\to(\mathscr{B}\to\mathscr{C}))\to ((\mathscr{A}\to\mathscr{B})\to(\mathscr{A}\to\mathscr{C})))$.</li><li>(K3) $(((\sim \mathscr{A})\to(\sim \mathscr{B}))\to (\mathscr{B}\to\mathscr{A}))$.</li><li>(K4) $((\forall x_i) \mathscr{A}\to \mathscr{A})$，如果 $x_i$ 不在 $\mathscr{A}$ 中自由出现。</li><li>(K5) $((\forall x_i) \mathscr{A}(x_i)\to \mathscr{A}(t))$，如果 $t$ 是 $\mathscr{L}$ 中的一个项，并且在 $\mathscr{A}(x_i)$ 中对 $x_i$ 自由。</li><li>(K6) $(\forall x_i)(\mathscr{A}\to\mathscr{B})\to(\mathscr{A}\to(\forall x_i)\mathscr{B})$，如果 $x_i$ 不在 $\mathscr{A}$ 中自由出现。</li></ul><p>演绎规则：</p><ul><li>MP：从 $\mathscr{A}$ 和 $(\mathscr{A}\to\mathscr{B})$ 可以演绎出 $\mathscr{B}$。</li><li>Generalization：从 $\mathscr{A}$ 可以演绎出 $(\forall x_i)\mathscr{A}$，其中 $x_i$ 是任意变元。</li></ul></blockquote><p>事实上，如果 $x_i$ 在 $\mathscr{A}$ 中自由出现，因为 $x_i$ 在 $\mathscr{A}$ 中对 $x_i$ 自由，可以由(K5) 知道，(K4) 仍然成立。所以，无论 $x_i$ 是否在 $\mathscr{A}$ 中自由出现，都有 $((\forall x_i) \mathscr{A}\to \mathscr{A})$。</p><blockquote><p><strong>Definition:</strong></p><p>$K_{\mathscr{L}}$ 中的一个 <em>证明 (proof)</em> 是指 $\mathscr{L}$ 的公式的这样一个序列 $\mathscr{A}_1, \cdots, \mathscr{A}_n$，使得对于每个 $i (1\leq i\leq n)$，$\mathscr{A}_i$ 或者是 $K_{\mathscr{L}}$ 的一个公理，或者是由位于 $\mathscr{A}_i$ 之前的公式通过 MP 或 Generalization 规则得到的。最后的公式 $\mathscr{A}_n$ 称为 $K_{\mathscr{L}}$ 中的一条 <em>定理 (theorem)</em>，记作 $\vdash_{K_{\mathscr{L}}} \mathscr{A}_n$。</p><p>如果 $\Gamma$ 是 $\mathscr{L}$ 中的一组合式公式，在 $K_{\mathscr{L}}$ 中从 $\Gamma$ 的一个 <em>演绎 (deduction)</em> 是指公式的这样一个序列 $\mathscr{A}_1, \cdots, \mathscr{A}_n$，使得对于每个 $i (1\leq i\leq n)$，$\mathscr{A}_i$ 或者是 $K_{\mathscr{L}}$ 的一个公理，或者是由位于 $\mathscr{A}_i$ 之前的公式通过 MP 或 Generalization 规则得到，或者是 $\Gamma$ 中的一个成员。记作 $\Gamma \vdash_{K_{\mathscr{L}}} \mathscr{A}_n$。</p></blockquote><p>以下用 $K$ 代替 $K_{\mathscr{L}}$。</p><blockquote><p><strong>Proposition (Soundness):</strong></p><p>(K1)-(K6) 都是逻辑有效的。这可以用定义证明。</p><p>由此可归纳出，$K$ 中的所有定理都是逻辑有效的。</p></blockquote><p>同样，$K$ 中也有 <em>演绎定理</em>，但不同于 $L$ 中的演绎定理，我们先来看一个特殊情况：</p><blockquote><p><strong>Proposition:</strong></p><p>我们知道对于 $K$ 中的任意公式 $\mathscr{A}$，都有 $\{\mathscr{A}\}\vdash_{K} (\forall x_i)\mathscr{A}$，但是 $\vdash_{K} (\mathscr{A} \to (\forall x_i)\mathscr{A})$ 并不是必然的。</p><p><strong>Proof:</strong></p><p>例如 $\{(x_1 = 0)\}\vdash_{K} (\forall x_1) (x_1 = 0)$，但是并没有 $\vdash_{K} ((x_1 = 0) \to (\forall x_1)(x_1 = 0))$。因为由 <em>满足</em> 定义的第四条可知，不存在赋值满足 $(\forall x_1)(x_1 = 0)$，所以 $((x_1 = 0) \to (\forall x_1)(x_1 = 0))$ 不是逻辑有效的，因此不是 $K$ 中的定理。</p></blockquote><blockquote><p><strong>Proposition ($K$ 的演绎定理，the deduction theorem)</strong></p><p>如果 $\Gamma\cup \{\mathscr{A}\} \vdash_{K}\mathscr{B}$，并且演绎过程中不涉及 $\mathscr{A}$ 中自由的变元，那么 $\Gamma\vdash_{K}(\mathscr{A}\to\mathscr{B})$。</p><p><strong>Proof:</strong>
类似于 $L$ 中演绎定理的证明，对 $\mathscr{B}$ 进行分类讨论。</p></blockquote><p>由演绎定理可得推论：</p><blockquote><p><strong>Proposition:</strong></p><p>如果 $\Gamma\cup \{\mathscr{A}\} \vdash_{K}\mathscr{B}$，并且 $\mathscr{A}$ 是闭公式，那么 $\Gamma\vdash_{K}(\mathscr{A}\to\mathscr{B})$。</p></blockquote><p>演绎定理的逆定理始终成立，无需加条件：</p><blockquote><p><strong>Proposition:</strong></p><p>如果 $\Gamma\vdash_{K}(\mathscr{A}\to\mathscr{B})$，那么 $\Gamma\cup \{\mathscr{A}\} \vdash_{K}\mathscr{B}$。</p></blockquote><p>$K$ 中同样有三段论：</p><blockquote><p><strong>Proposition (HS):</strong></p><p>对任意公式 $\mathscr{A}, \mathscr{B}, \mathscr{C}$，如果 $\{(\mathscr{A}\to\mathscr{B}), (\mathscr{B}\to\mathscr{C})\}\vdash_{K}(\mathscr{A}\to\mathscr{C})$。</p></blockquote><p>同样有替换定理：</p><blockquote><p><strong>Proposition:</strong></p><p>$\mathscr{A}$ 和 $\mathscr{B}$ 是 $\mathscr{L}$ 中的闭公式，如果 $\mathscr{B}_0$ 是由 $\mathscr{A}_0$ 通过将其中的 $\mathscr{A}$ 替换成 $\mathscr{B}$ 得到的，那么有：
$$\vdash_{K}(\mathscr{A}\leftrightarrow \mathscr{B})\to (\mathscr{A}_0\leftrightarrow \mathscr{B}_0)$$</p></blockquote><blockquote><p><strong>Proposition:</strong></p><p>如果 $x_i$ 不在 $\mathscr{A}$ 中自由出现，那么</p><ul><li>$\vdash_{K}(\forall x_i)(\mathscr{A}\to \mathscr{B})\leftrightarrow (\mathscr{A}\to(\forall x_i)\mathscr{B})$</li><li>$\vdash_{K}(\exists x_i)(\mathscr{A}\to \mathscr{B})\leftrightarrow (\mathscr{A}\to(\exists x_i)\mathscr{B})$</li></ul><p>如果 $x_i$ 不在 $\mathscr{B}$ 中自由出现，那么</p><ul><li>$\vdash_{K}(\forall x_i)(\mathscr{A}\to \mathscr{B})\leftrightarrow ((\exists x_i)\mathscr{A}\to\mathscr{B})$</li><li>$\vdash_{K}(\exists x_i)(\mathscr{A}\to \mathscr{B})\leftrightarrow ((\forall x_i)\mathscr{A}\to\mathscr{B})$</li></ul></blockquote><h3 id=前束范式>前束范式</h3><blockquote><p><strong>Definition:</strong></p><p>$\mathscr{L}$ 中的一个公式 $\mathscr{A}$ 称为 <em>前束范式 (prenex form)</em>，如果它形如:
$$(Q_1 x_{i1})(Q_2 x_{i2})(Q_k x_{ik})\mathscr{D}$$
其中 $Q_j$ 是 $\forall$ 或 $\exists$，$\mathscr{D}$ 是不带量词的公式。</p></blockquote><blockquote><p><strong>Proposition:</strong></p><p>$\mathscr{L}$ 中的任意合式公式 $\mathscr{A}$，总存在前束范式 $\mathscr{B}$ 等价于 $\mathscr{A}$。</p><p><strong>Proof:</strong>
由上一条 proposition 可证。</p></blockquote><blockquote><p><strong>Definition:</strong></p><p>一个前束范式是一个 $\Pi_n$ 式，如果它以 $\forall$ 开头，并有 $n-1$ 次量词交叉。</p><p>一个前束范式是一个 $\Sigma_n$ 式，如果它以 $\exists$ 开头，并有 $n-1$ 次量词交叉。</p></blockquote><p>比如 $(\exists x_3)(\forall x_1)(\forall x_4)(\forall x_5) A(x_1,x_2,x_3,x_4,x_5)$ 就是 $\Sigma_2$ 式。</p><h3 id=k_mathscrl-的完备性定理>$K_{\mathscr{L}}$ 的完备性定理</h3><p>与 $L$ 一样， $K$ 也满足 soundness, consistency, adequacy，因此 $K$ 中的定理 $\iff$ 逻辑有效。</p><blockquote><p><strong>Proposition (Adequacy, 完备性):</strong></p><p>所有逻辑有效的公式都是 $K$ 中的定理。也被称为 <em>一阶逻辑的哥德尔完备性定理</em>。</p><p><strong>Proof:</strong>
过于复杂不便展示。</p></blockquote><h3 id=模型>模型</h3><blockquote><p><strong>Definition:</strong></p><p>如果 $S$ 是一个一阶逻辑系统，$S$ 的一个 <em>模型 (model)</em> 指的是一个解释，使得 $S$ 中的所有定理都为真。</p></blockquote><blockquote><p><strong>Theorem:</strong></p><p>如果 $I$ 是一个解释，使得 $S$ 的所有公理都为真，那么 $I$ 是 $S$ 的一个模型。</p></blockquote><h2 id=数学系统>数学系统</h2><p>现在要在 $K$ 的基础上加些数学。</p><h3 id=一阶算术>一阶算术</h3><blockquote><p><strong>Definition:</strong></p><p><em>一阶算术 $\mathscr{N}$ (first order arithmetic)</em> 是 $K$ 的一个一致扩充，额外引入了以下公理：</p><ul><li>(E7) $x_1=x_1$</li><li>(E8) $t_k=u\to f_i^n(t_1,\cdots,t_k,\cdots,t_n)=f^n_i(t_1,\cdots,u,\cdots,t_n)$</li><li>(E9) $t_k=u\to (A_i^n(t_1,\cdots,t_k,\cdots,t_n)\to A^n_i(t_1,\cdots,u,\cdots,t_n))$</li><li>(N1) $(\forall x_1) \sim (x_1^{\prime}=0)$</li><li>(N2) $(\forall x_1)(\forall x_2)(x_1^{\prime}=x_2^{\prime} \to x_1=x_2)$</li><li>(N3) $(\forall x_1) (x_1+0=x_1)$</li><li>(N4) $(\forall x_1)(\forall x_2)((x_1+x_2^{\prime})=(x_1+x_2)^{\prime})$</li><li>(N5) $(\forall x_1)(x_1\times 0=0)$</li><li>(N6) $(\forall x_1)(\forall x_2)((x_1\times x_2^{\prime})=(x_1\times x_2)+x_1)$</li><li>(N7) $\mathscr{A}(0) \to ((\forall x_1)(\mathscr{A}(x_1)\to\mathscr{A}(x_1^{\prime}))\to (\forall x_1)\mathscr{A}(x_1))$，其中 $x_1$ 在 $\mathscr{A}(x_1)$ 中自由出现。</li></ul></blockquote><p>只有 0 是 $\mathscr{N}$ 中的符号。而 $1, 2, 3, \cdots$ 被表示为 $0^{\prime}, 0^{\prime\prime}, 0^{\prime\prime\prime}, \cdots$</p><h2 id=gödel-incompleteness-theorem-哥德尔不完全性定理>Gödel incompleteness theorem (哥德尔不完全性定理)</h2><p>这部分先放着吧，有兴趣有必要了再写。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/theory-of-computation/>Theory of Computation</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Apr 02, 2024 17:00 UTC</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/theory-of-computation-lecture-4/><div class=article-image><img src=/p/theory-of-computation-lecture-4/cover.5a4cd64d97d6d054c8c5b7c90f52a40a_hu6720720966422977467.png width=250 height=150 loading=lazy alt="Featured image of post Theory of Computation Lecture 4" data-key=Theory-of-Computation-Lecture-4 data-hash="md5-WkzWTZfW0FTIxbfJD1KkCg=="></div><div class=article-details><h2 class=article-title>Theory of Computation Lecture 4</h2></div></a></article><article class=has-image><a href=/p/theory-of-computation-lecture-3/><div class=article-image><img src=/p/theory-of-computation-lecture-3/cover.5f5e9c4304a2514432b7282528d1e5b3_hu4880160208832955682.png width=250 height=150 loading=lazy alt="Featured image of post Theory of Computation Lecture 3" data-key=Theory-of-Computation-Lecture-3 data-hash="md5-X16cQwSiUUQytyglKNHlsw=="></div><div class=article-details><h2 class=article-title>Theory of Computation Lecture 3</h2></div></a></article><article class=has-image><a href=/p/theory-of-computation-lecture-1/><div class=article-image><img src=/p/theory-of-computation-lecture-1/cover.86b4cdeb0eca4d88890d85ec894e304c_hu14731684250797830019.png width=250 height=150 loading=lazy alt="Featured image of post Theory of Computation Lecture 1" data-key=Theory-of-Computation-Lecture-1 data-hash="md5-hrTN6w7KTYiJDYXsiU4wTA=="></div><div class=article-details><h2 class=article-title>Theory of Computation Lecture 1</h2></div></a></article><article><a href=/p/drl-notes-6/><div class=article-details><h2 class=article-title>Deep Reinforcement Learning Lecture 6</h2></div></a></article><article><a href=/p/drl-notes-5/><div class=article-details><h2 class=article-title>Deep Reinforcement Learning Lecture 5</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=SUZ-tsinghua/SUZ-tsinghua.github.io issue-term=title crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2024 suz</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>