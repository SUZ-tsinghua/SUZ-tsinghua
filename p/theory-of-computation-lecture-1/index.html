<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Mathematical Logic (1)"><title>Theory of Computation Lecture 1</title>
<link rel=canonical href=https://suz-tsinghua.github.io/p/theory-of-computation-lecture-1/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="Theory of Computation Lecture 1"><meta property='og:description' content="Mathematical Logic (1)"><meta property='og:url' content='https://suz-tsinghua.github.io/p/theory-of-computation-lecture-1/'><meta property='og:site_name' content='suz'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Theory of Computation'><meta property='article:published_time' content='2024-03-26T17:00:00+00:00'><meta property='article:modified_time' content='2024-03-26T17:00:00+00:00'><meta property='og:image' content='https://suz-tsinghua.github.io/p/theory-of-computation-lecture-1/cover.png'><meta name=twitter:title content="Theory of Computation Lecture 1"><meta name=twitter:description content="Mathematical Logic (1)"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://suz-tsinghua.github.io/p/theory-of-computation-lecture-1/cover.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu1189040654346373991.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>😇</span></figure><div class=site-meta><h1 class=site-name><a href=/>suz</a></h1><h2 class=site-description></h2></div></header><ol class=menu-social><li><a href=https://github.com/SUZ-tsinghua target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href='https://scholar.google.com/citations?user=R5Y1xlUAAAAJ&amp;hl=zh-CN&amp;oi=sra' target=_blank title="Google scholar" rel=me><svg class="icon icon-tabler icon-tabler-brand-google" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M20.945 11a9 9 0 11-3.284-5.997l-2.655 2.392A5.5 5.5.0 1017.125 14H13v-3h7.945z"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#informal-statement-calculus-非形式的命题演算>Informal Statement Calculus (非形式的命题演算)</a><ol><li><a href=#命题联结词和真值表>命题、联结词和真值表</a></li><li><a href=#运算和代入规则>运算和代入规则</a></li><li><a href=#范式>范式</a></li><li><a href=#联结词的完全集>联结词的完全集</a></li><li><a href=#论证和有效性>论证和有效性</a></li></ol></li><li><a href=#formal-statement-calculus-形式的命题演算>Formal Statement Calculus (形式的命题演算)</a><ol><li><a href=#命题演算形式系统-l>命题演算形式系统 $L$</a></li><li><a href=#l-的完备性定理>$L$ 的完备性定理</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/theory-of-computation-lecture-1/><img src=/p/theory-of-computation-lecture-1/cover_hu12143059186346951675.png srcset="/p/theory-of-computation-lecture-1/cover_hu12143059186346951675.png 800w, /p/theory-of-computation-lecture-1/cover_hu14860106829907384747.png 1600w" width=800 height=192 loading=lazy alt="Featured image of post Theory of Computation Lecture 1"></a></div><div class=article-details><header class=article-category><a href=/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/>课程笔记</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/theory-of-computation-lecture-1/>Theory of Computation Lecture 1</a></h2><h3 class=article-subtitle>Mathematical Logic (1)</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 26, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 10 分钟</time></div></footer></div></header><section class=article-content><h1 id=lecture-1-mathematical-logic-1>Lecture 1 Mathematical Logic (1)</h1><h2 id=informal-statement-calculus-非形式的命题演算>Informal Statement Calculus (非形式的命题演算)</h2><h3 id=命题联结词和真值表>命题、联结词和真值表</h3><p>自然语言中有许多命题 (statement)，比如“拿破仑死了”。而命题之间又可以通过联结词 (connective) 组成更复杂的命题，比如“拿破仑死了<em>并且</em>世界正在欢腾”。在这里，我们假设所有的命题都是非真即假的。常见的联结词及其对应的含义可见下表：</p><div class=table-wrapper><table><thead><tr><th>Meaning</th><th>Connectives</th></tr></thead><tbody><tr><td>not $A$</td><td>$\sim A$</td></tr><tr><td>$A$ and $B$</td><td>$A \land B$</td></tr><tr><td>$A$ or $B$</td><td>$A \lor B$</td></tr><tr><td>if $A$ then $B$</td><td>$A \to B$</td></tr><tr><td>$A$ if and only if $B$</td><td>$A \leftrightarrow B$</td></tr></tbody></table></div><p>“拿破仑死了<em>并且</em>世界正在欢腾”就可以用$A \land B$表示。</p><p>各联结词的真值表如下所示：</p><p>Negation:</p><div class=table-wrapper><table><thead><tr><th>$p$</th><th>$\sim p$</th></tr></thead><tbody><tr><td>$T$</td><td>$F$</td></tr><tr><td>$F$</td><td>$T$</td></tr></tbody></table></div><p>Conjunction:</p><div class=table-wrapper><table><thead><tr><th>$p$</th><th>$q$</th><th>$p \land q$</th></tr></thead><tbody><tr><td>$T$</td><td>$T$</td><td>$T$</td></tr><tr><td>$T$</td><td>$F$</td><td>$F$</td></tr><tr><td>$F$</td><td>$T$</td><td>$F$</td></tr><tr><td>$F$</td><td>$F$</td><td>$F$</td></tr></tbody></table></div><p>Disjunction:</p><div class=table-wrapper><table><thead><tr><th>$p$</th><th>$q$</th><th>$p \lor q$</th></tr></thead><tbody><tr><td>$T$</td><td>$T$</td><td>$T$</td></tr><tr><td>$T$</td><td>$F$</td><td>$T$</td></tr><tr><td>$F$</td><td>$T$</td><td>$T$</td></tr><tr><td>$F$</td><td>$F$</td><td>$F$</td></tr></tbody></table></div><p>Conditional:</p><div class=table-wrapper><table><thead><tr><th>$p$</th><th>$q$</th><th>$p \to q$</th></tr></thead><tbody><tr><td>$T$</td><td>$T$</td><td>$T$</td></tr><tr><td>$T$</td><td>$F$</td><td>$F$</td></tr><tr><td>$F$</td><td>$T$</td><td>$T$</td></tr><tr><td>$F$</td><td>$F$</td><td>$T$</td></tr></tbody></table></div><p>Conditional 的真值表的前两行并不难理解，后两行则可以认为是一种定义上的方便。因为采取这样的定义后，在判断 $p\to q$ 是否恒为真时只需要判断 $p$ 为真是否始终能推出 $q$ 为真即可，而不需要考察 $p$ 为假的情况，这与先前的认知是一致的。</p><p>Biconditional:</p><div class=table-wrapper><table><thead><tr><th>$p$</th><th>$q$</th><th>$p \leftrightarrow q$</th></tr></thead><tbody><tr><td>$T$</td><td>$T$</td><td>$T$</td></tr><tr><td>$T$</td><td>$F$</td><td>$F$</td></tr><tr><td>$F$</td><td>$T$</td><td>$F$</td></tr><tr><td>$F$</td><td>$F$</td><td>$T$</td></tr></tbody></table></div><p>类似表中的字母 $p, q, r, \cdots$ 称为命题变元 (statement variable)，它们表示任意的非特定的单个命题。而由命题变元和联结词组成的表达式称为命题形式 (statement form)，定义如下：</p><blockquote><p><strong>Definition:</strong></p><p>一个 <em>命题形式</em> 是一个含有命题变元和联结词的表达式，并且能用以下规则构成：</p><p>(1) 任何命题变元是一个命题形式。</p><p>(2) 如果 $\mathscr{A}$ 和 $\mathscr{B}$ 是命题形式，那么 $(\sim \mathscr{A}), (\mathscr{A} \land \mathscr{B}), (\mathscr{A}\lor \mathscr{B}), (\mathscr{A}\to\mathscr{B}), (\mathscr{A} \leftrightarrow \mathscr{B})$ 是命题形式。</p></blockquote><p>每个命题形式都有其真值表。</p><blockquote><p><strong>Definition:</strong></p><p>(1) 一命题形式称为 <em>重言式 (tautology)</em> ，如果对于其中出现的命题变元的各种可能的真值指派，它总取真值为 <em>T</em> 。</p><p>(2) 一命题形式称为 <em>矛盾式 (contradiction)</em> ，如果对于其中出现的命题变元的各种可能的真值指派，它总取真值为 <em>F</em> 。</p></blockquote><p>$(p\lor \sim p)$ 是一个重言式，而 $(q\land \sim q)$ 是一个矛盾式。</p><blockquote><p><strong>Definition:</strong></p><p>设 $\mathscr{A}$ 和 $\mathscr{B}$ 是命题形式，我们说 $\mathscr{A}$ <em>逻辑蕴含 (logically implies)</em> $\mathscr{B}$，如果 $(\mathscr{A}\to\mathscr{B})$ 是一重言式，我们说 $\mathscr{A}$ <em>逻辑等值 (logically equivalent)</em> $\mathscr{B}$，如果 $(\mathscr{A}\leftrightarrow\mathscr{B})$ 是一重言式。</p></blockquote><p>$(p\land q)$ 逻辑蕴含 $p$，$(\sim(p\land q))$ 逻辑等值 $((\sim p)\lor(\sim q))$。</p><h3 id=运算和代入规则>运算和代入规则</h3><blockquote><p><strong>Proposition:</strong></p><p>如果 $\mathscr{A}$ 和 $(\mathscr{A}\to\mathscr{B})$ 都是重言式，那么 $\mathscr{B}$ 也是重言式。</p><p><strong>Proof:</strong>
omitted.</p></blockquote><blockquote><p><strong>Proposition (Rules for Substitution):</strong></p><p>令 $\mathscr{A}$ 是一个命题形式，其中有命题变元 $p_1, p_2, \cdots, p_n$，并且令 $\mathscr{A}_1, \mathscr{A}_2, \cdots, \mathscr{A}_n$ 是任意命题形式。如果 $\mathscr{A}$ 是一个重言式，那么由 $\mathscr{A}$ 通过用 $\mathscr{A}_i$ 到处去替换每个 $p_i$ 而得到的 $\mathscr{B}$ 也是一重言式。</p><p><strong>Proof:</strong>
omitted.</p></blockquote><p>比如，$(p\land q)$ 逻辑蕴含 $p$，所以对任意 $\mathscr{A}, \mathscr{B}$，都有 $(\mathscr{A}\land \mathscr{B})$ 逻辑蕴含 $\mathscr{A}$。</p><blockquote><p><strong>Proposition (De Morgan&rsquo;s Law):</strong></p><p>令 $\mathscr{A}_1, \mathscr{A}_2, \cdots, \mathscr{A}_n$ 是任意的命题形式，那么：</p><p>(1) $(\mathop{\lor}\limits_{i=1}^n (\sim\mathscr{A}_i))$ 逻辑等值于 $(\sim(\mathop{\land}\limits_{i=1}^n \mathscr{A}_i))$</p><p>(2) $(\mathop{\land}\limits_{i=1}^n (\sim\mathscr{A}_i))$ 逻辑等值于 $(\sim(\mathop{\lor}\limits_{i=1}^n \mathscr{A}_i))$</p><p><strong>Proof:</strong></p><p>用数学归纳法，先用 Rules for Substitution 证明 $n=2$ 的情形，再推广至任意正整数 $n$。</p></blockquote><h3 id=范式>范式</h3><blockquote><p><strong>Definition:</strong></p><p>定义只含有联结词 $\sim, \land, \lor$ 的命题形式为 <em>限制的命题形式 (restricted statement form)</em> 。</p></blockquote><blockquote><p><strong>Proposition:</strong></p><p>每个非矛盾的命题形式逻辑等值于一个限制的命题形式 $\mathop{\lor}\limits_{i=1}^m(\mathop{\land}_{j=1}^n Q_{ij})$，其中每个 $Q_{ij}$ 或是一个命题变元，或是一个命题变元的否定。这个形式称为 <em>析取范式 (disjunctive normal form)</em> 。</p><p>每个非重言的命题形式逻辑等值于一个限制的命题形式 $\mathop{\land}\limits_{i=1}^m(\mathop{\lor}_{j=1}^n Q_{ij})$，其中每个 $Q_{ij}$ 或是一个命题变元，或是一个命题变元的否定。这个形式称为 <em>合取范式 (conjunctive normal form)</em> 。</p><p><strong>Proof:</strong></p><p>仅对析取范式进行证明，合取范式同理。仅需证明任意真值表中只有一行为 $T$ 的命题形式可以用 $\mathop{\land}_{j=1}^n Q_{j}$ 表示即可。多行为 $T$ 的命题形式可由一行为 $T$ 的命题形式通过 $\lor$ 联结得到。</p><p>对于每个命题变元 $q_j$，若其在真值表中的那一行取 $T$，则 $Q_{j}=q_j$，否则取 $Q_{j}=\sim q_j$。</p><p>这样就可以对任意非矛盾的命题形式构造出一个与其逻辑等值的析取范式。</p></blockquote><p>综合可得：</p><blockquote><p><strong>Proposition:</strong></p><p>每个真值函数都可以用一个限制的命题形式表示。</p></blockquote><h3 id=联结词的完全集>联结词的完全集</h3><blockquote><p><strong>Definition:</strong></p><p>一个 <em>联结词的完全集 (adequate set of connectives)</em> 是这样一个集合，使得每个真值函数都能由仅仅含有该集中的联结词的命题形式所表示。</p></blockquote><p>显然，$\{\sim, \lor, \land\}$ 是一个完全集。</p><blockquote><p><strong>Proposition:</strong></p><p>$\{\sim, \land\}, \{\sim, \lor\}, \{\sim, \to\}$ 都是完全集。</p><p><strong>Proof:</strong></p><p>可以用 $\{\sim, \lor, \land\}$ 是完全集来证明。</p></blockquote><p>然而，以上介绍的联结词均不能单独构成一个完全集，不过可以通过引入新的联结词来构成只含一个联结词的完全集。</p><p>NOR（即 not+or）</p><div class=table-wrapper><table><thead><tr><th>$p$</th><th>$q$</th><th>$p \downarrow q$</th></tr></thead><tbody><tr><td>$T$</td><td>$T$</td><td>$F$</td></tr><tr><td>$T$</td><td>$F$</td><td>$F$</td></tr><tr><td>$F$</td><td>$T$</td><td>$F$</td></tr><tr><td>$F$</td><td>$F$</td><td>$T$</td></tr></tbody></table></div><p>NAND（即 not+and）</p><div class=table-wrapper><table><thead><tr><th>$p$</th><th>$q$</th><th>$p | q$</th></tr></thead><tbody><tr><td>$T$</td><td>$T$</td><td>$F$</td></tr><tr><td>$T$</td><td>$F$</td><td>$T$</td></tr><tr><td>$F$</td><td>$T$</td><td>$T$</td></tr><tr><td>$F$</td><td>$F$</td><td>$T$</td></tr></tbody></table></div><blockquote><p><strong>Proposition:</strong></p><p>$\{\downarrow\}, \{ | \}$ 都是联结词的完全集。</p><p><strong>Proof:</strong></p><p>可以用已知的完全集来证明。</p></blockquote><p>但是仅使用一个联结词可能会导致表达式非常复杂，比如仅用 $\downarrow$ 构造出 $(p\to q)$：</p><p>$$\{(p\downarrow p)\downarrow [(q\downarrow q)\downarrow (q\downarrow q)]\}\downarrow \{(p\downarrow p)\downarrow [(q\downarrow q)\downarrow (q\downarrow q)]\}$$</p><h3 id=论证和有效性>论证和有效性</h3><blockquote><p><strong>Definition:</strong></p><p><em>论证形式 (argument form)</em> 定义为类似：</p><p>$$\mathscr{A}_1, \mathscr{A}_2, \cdots, \mathscr{A}_n; \therefore \mathscr{A}$$</p><p>的形式。</p><p>我们称一个论证形式是 <em>无效 (nonvalid)</em> 的，如果存在一种对命题变元的真值指派，使得每个 $\mathscr{A}_i$ 均取值 $T$，但是 $\mathscr{A}$ 取值 $F$。否则称其是 <em>有效 (valid)</em> 的。</p></blockquote><blockquote><p><strong>Proposition:</strong></p><p>论证形式
$$\mathscr{A}_1, \mathscr{A}_2, \cdots, \mathscr{A}_n; \therefore \mathscr{A}$$</p><p>是有效的，当且仅当命题形式</p><p>$$((\mathscr{A}_1\land \mathscr{A}_2 \land \cdots \land \mathscr{A}_n) \to \mathscr{A})$$</p><p>是一个重言式。</p><p><strong>Proof:</strong>
omitted.</p></blockquote><h2 id=formal-statement-calculus-形式的命题演算>Formal Statement Calculus (形式的命题演算)</h2><h3 id=命题演算形式系统-l>命题演算形式系统 $L$</h3><p>我们主要关注两个特殊的形式系统（命题演算形式系统、谓词演算形式系统），我们先给出形式系统的一般性定义：</p><blockquote><p><strong>Definition:</strong></p><p>一个 <em>形式系统 (formal system)</em> 由以下几部分构成：</p><p>(1) 一个符号库 (an alphabet of symbols)。</p><p>(2) 这些符号组成的有限字符串（称为合式公式，well-formed fomula）的一个集合。</p><p>(3) 合式公式的一个集合，称为公理 (axiom)。</p><p>(4) 有限个演绎规则 (rules of deduction) 组成的集合。</p></blockquote><p>接下来给出命题演算形式系统的定义：</p><blockquote><p><strong>Definition:</strong></p><p>一个 <em>命题演算形式系统 L (formal system L of statement calculus)</em> 由以下几部分构成：</p><p>(1) 一个无限的符号库：</p><p>$$\sim, \to, (, ), p_1, p_2, p_3, \cdots$$</p><p>(2) 一个合式公式的集合，由以下规则确定：</p><ul><li>对于每个 $i\geq 1$, $p_i$ 是合式公式。</li><li>如果 $\mathscr{A}$ 和 $\mathscr{B}$ 是合式公式，那么 $(\sim \mathscr{A})$ 和 $(\mathscr{A}\to\mathscr{B})$ 也是合式公式。</li><li>所有合式公式都由以上两条规则产生。</li></ul><p>(3) 一个公理的集合，对于任何合式公式 $\mathscr{A}, \mathscr{B}, \mathscr{C}$，以下公式是 $L$ 的公理：</p><ul><li>(L1) $(\mathscr{A}\to(\mathscr{B}\to\mathscr{A}))$.</li><li>(L2) $((\mathscr{A}\to(\mathscr{B}\to\mathscr{C}))\to ((\mathscr{A}\to\mathscr{B})\to(\mathscr{A}\to\mathscr{C})))$.</li><li>(L3) $(((\sim \mathscr{A})\to(\sim \mathscr{B}))\to (\mathscr{B}\to\mathscr{A}))$.</li></ul><p>(4) $L$ 中仅有一条演绎规则，称为 modus ponens (MP)，即对于 $L$ 中的任何公式 $\mathscr{A}$ 和 $(\mathscr{A}\to\mathscr{B})$，$\mathscr{B}$ 也是 $L$ 中的一个公式。</p></blockquote><p>目前而言，在考察 $L$ 中的公式及其演绎时，不应考虑其是否“正确”，而应将其完全视为一文字游戏，只能通过已有公式与演绎规则推出新的合式公式。而至于新推出的合式公式的“正确性”（即新公式为一重言式），则由“公理为重言式”（可直接验证），以及“演绎规则保持公式的重言性”（先前已证明）来保证。</p><blockquote><p><strong>Definition:</strong></p><p>$L$ 中的一个 <em>证明 (proof)</em> 是指公式的这样一个序列 $\mathscr{A}_1, \cdots, \mathscr{A}_n$，使得对于每个 $i (1\leq i\leq n)$，或者 $\mathscr{A}_i$ 是 $L$ 的一个公理，或者 $\mathscr{A}_i$ 可由序列中位于 $\mathscr{A}_i$ 前面的两个公式 $\mathscr{A}_j, \mathscr{A}_k (j,k&lt;i)$ 通过 MP 得到。这样的证明称为在 $L$ 中 $\mathscr{A}_n$ 的一个证明，$\mathscr{A}_n$ 称为 $L$ 中的一个 <em>定理 (theorem)</em>。</p><p>$\mathscr{A}_n$ 是 $L$ 中的一个定理可记作 $\vdash_L \mathscr{A}_n$。</p></blockquote><blockquote><p><strong>Exercise:</strong></p><p>Prove: $\vdash_L (\mathscr{A}\to\mathscr{A})$.</p><p><strong>Solution:</strong></p><p>$$\begin{align*}
(1)&\quad (\mathscr{A}\to((\mathscr{A}\to\mathscr{A})\to\mathscr{A})) &&(L1)\\
(2)&\quad ((\mathscr{A}\to(\mathscr{A}\to\mathscr{A}))\to(\mathscr{A}\to\mathscr{A})) &&(1)+(L2)+MP\\
(3)&\quad (\mathscr{A}\to(\mathscr{A}\to\mathscr{A})) &&(L1)\\
(4)&\quad (\mathscr{A}\to\mathscr{A}) &&(2)+(3)+MP
\end{align*}$$</p></blockquote><blockquote><p><strong>Definition:</strong></p><p>令 $\Gamma$ 是 $L$ 中的公式集（可以是也可以不是 $L$ 中的公理或定理）。$L$ 中的公式序列 $\mathscr{A}_1, \cdots, \mathscr{A}_n$ 是从 $\Gamma$ 的一个 <em>演绎 (deduction)</em>，如果每个 $i (1\leq i\leq n)$，下列之一成立：</p><ul><li>$\mathscr{A}_i$ 是 $L$ 的一个公理。</li><li>$\mathscr{A}_i$ 是 $\Gamma$ 中的一个成员。</li><li>$\mathscr{A}_i$ 可由序列中在 $\mathscr{A}_i$ 前的两个公式通过 MP 得到。</li></ul><p>记作 $\Gamma\vdash_L \mathscr{A}_n$。</p></blockquote><blockquote><p><strong>Exercise:</strong></p><p>Prove: $\{\mathscr{A},(\mathscr{B}\to(\mathscr{A}\to\mathscr{C}))\}\vdash_L (\mathscr{B}\to\mathscr{C})$.</p><p><strong>Solution:</strong></p><p>$$\begin{align*}
(1)&\quad \mathscr{A} &&假设\\
(2)&\quad (\mathscr{A}\to(\mathscr{B}\to\mathscr{A})) &&(L1)\\
(3)&\quad (\mathscr{B}\to\mathscr{A}) &&(1)+(2)+MP\\
(4)&\quad (\mathscr{B}\to(\mathscr{A}\to\mathscr{C})) &&假设\\
(5)&\quad ((\mathscr{B}\to\mathscr{A})\to(\mathscr{B}\to\mathscr{C})) &&(4)+(L2)+MP\\
(6)&\quad (\mathscr{B}\to\mathscr{C}) &&(3)+(5)+MP
\end{align*}$$</p></blockquote><p>注意，这样子推出来的公式并不一定是 $L$ 中的一个定理。</p><blockquote><p><strong>Proposition (The deduction theorem):</strong></p><p>$\Gamma\cup\{\mathscr{A}\}\vdash_L\mathscr{B}$ 当且仅当 $\Gamma\vdash_L(\mathscr{A}\to\mathscr{B})$，其中 $\mathscr{A}$ 和 $\mathscr{B}$ 是 $L$ 中的公式，$\Gamma$ 是 $L$ 的公式集（可能是空集）。</p><p><strong>Proof:</strong></p><p>仅证明从左至右的部分，从右至左可以直接运用 MP。运用数学归纳法证明从左至右的部分，假设从 $\Gamma\cup\{\mathscr{A}\}$ 到 $\mathscr{B}$ 的演绎是一个有 $n$ 个公式的序列。</p><p>(1) $n=1$ 时，三种情况：</p><ul><li>$\mathscr{B}$ 是 $L$ 中的一条公理，则有：
$$\begin{align*}
(1)&\quad \mathscr{B} &&公理\\
(2)&\quad (\mathscr{B}\to (\mathscr{A}\to\mathscr{B})) &&(L1)\\
(3)&\quad (\mathscr{A}\to\mathscr{B}) && (1)+(2)+MP
\end{align*}$$</li><li>$\mathscr{B}\in \Gamma$，则同上一种情况。</li><li>$\mathscr{B}=\mathscr{A}$，先前已证 $\vdash_L (\mathscr{A}\to\mathscr{A})$。</li></ul><p>(2) 假设从 $\Gamma\cup\{\mathscr{A}\}$ 到 $\mathscr{B}$ 的演绎长度 $&lt; n$ 时，proposition 成立。可以假设 $\mathscr{B}$ 不是 $L$ 中的公理，不在 $\Gamma$ 中，不为 $\mathscr{A}$，那么在 $\Gamma\cup\{\mathscr{A}\}$ 到 $\mathscr{B}$ 的演绎序列中， $\mathscr{B}$ 只可能由先前的两个公式 $\mathscr{C}$ 和 $(\mathscr{C}\to\mathscr{B})$ 通过 MP 得到。故而我们有 $\Gamma\cup \{\mathscr{A}\} \vdash_L \mathscr{C}$ 和 $\Gamma\cup \{\mathscr{A}\} \vdash_L (\mathscr{C}\to\mathscr{B})$。由归纳假设，$\Gamma\vdash_L(\mathscr{A}\to\mathscr{C}), \Gamma\vdash_L(\mathscr{A}\to(\mathscr{C}\to\mathscr{B}))$。由二者，通过 (L2) 和 MP 可得 $\Gamma\vdash_L(\mathscr{A}\to\mathscr{B})$。</p><p>这个 proposition 被称为 <em>演绎定理</em>。</p></blockquote><blockquote><p><strong>Proposition (Hypothetical Syllogism (HS)):</strong></p><p>对任何 $L$ 中的公式 $\mathscr{A}, \mathscr{B}, \mathscr{C}$：</p><p>$$\{(\mathscr{A}\to\mathscr{B}), (\mathscr{B}\to\mathscr{C})\} \vdash_L (\mathscr{A}\to\mathscr{C})$$</p><p><strong>Proof:</strong></p><p>$$\begin{align*}
(1)&\quad (\mathscr{A}\to\mathscr{B}) &&假设\\
(2)&\quad (\mathscr{B}\to \mathscr{C}) &&假设\\
(3)&\quad \mathscr{A} &&假设\\
(4)&\quad \mathscr{B} &&(1)+(3)+MP \\
(5)&\quad \mathscr{C} &&(2)+(4)+MP \\
\end{align*}$$
所以有 $\{(\mathscr{A}\to\mathscr{B}), (\mathscr{B}\to\mathscr{C}), \mathscr{A}\} \vdash_L \mathscr{C}$，根据演绎定理，可得 $\{(\mathscr{A}\to\mathscr{B}), (\mathscr{B}\to\mathscr{C})\} \vdash_L (\mathscr{A}\to\mathscr{C})$。</p><p>此 proposition 被称为 <em>假言三段论</em>。</p></blockquote><blockquote><p><strong>Exercise:</strong></p><p>Prove:</p><p>(1) $\vdash_L(\sim\mathscr{B}\to(\mathscr{B}\to\mathscr{A}))$.</p><p>(2) $\vdash_L((\sim\mathscr{A}\to\mathscr{A})\to\mathscr{A})$.</p><p><strong>Proof:</strong></p><p>(1)
$$\begin{align*}
(1)&\quad (\sim \mathscr{B}\to(\sim\mathscr{A}\to\sim\mathscr{B})) &&(L1)\\
(2)&\quad ((\sim\mathscr{A}\to\sim\mathscr{B})\to(\mathscr{B}\to\mathscr{A})) &&(L2)\\
(3)&\quad (\sim \mathscr{B}\to(\mathscr{B}\to\mathscr{A})) &&(1)+(2)+HS\\
\end{align*}$$
(2) 由演绎定理，只需证明 $\{(\sim \mathscr{A}\to\mathscr{A})\}\vdash_L \mathscr{A}$：
$$\begin{align*}
(1)&\quad (\sim\mathscr{A}\to\mathscr{A}) &&假设\\
(2)&\quad (\sim\mathscr{A}\to(\sim\sim(\sim\mathscr{A}\to\mathscr{A})\to\sim\mathscr{A})) &&(L1)\\
(3)&\quad ((\sim\sim(\sim\mathscr{A}\to\mathscr{A})\to\sim\mathscr{A}) \to (\mathscr{A}\to\sim(\sim\mathscr{A}\to\mathscr{A}))) &&(L3)\\
(4)&\quad (\sim\mathscr{A}\to (\mathscr{A}\to\sim(\sim\mathscr{A}\to\mathscr{A}))) &&(2)+(3)+HS\\
(5)&\quad ((\sim\mathscr{A}\to \mathscr{A})\to (\sim\mathscr{A}\to\sim(\sim\mathscr{A}\to\mathscr{A}))) &&(4)+(L2)+MP\\
(6)&\quad ((\sim\mathscr{A}\to\sim(\sim\mathscr{A}\to\mathscr{A})) \to ((\sim\mathscr{A}\to\mathscr{A})\to\mathscr{A})) &&(L2)\\
(7)&\quad ((\sim\mathscr{A}\to\mathscr{A})\to((\sim\mathscr{A}\to\mathscr{A})\to\mathscr{A})) &&(5)+(6)+HS\\
(8)&\quad \mathscr{A} &&(1)+(7)+2\times MP
\end{align*}$$</p></blockquote><h3 id=l-的完备性定理>$L$ 的完备性定理</h3><blockquote><p><strong>Definition:</strong></p><p>$L$ 的一个 <em>赋值 (valuation)</em> 是一个函数 $v$，它的定义域是 $L$ 的公式，值域是集合 $\{T, F\}$，并且使得对 $L$ 的任意公式 $\mathscr{A}, \mathscr{B}$：</p><p>(1) $v(\mathscr{A})\neq v(\sim\mathscr{A})$.</p><p>(2) $v(\mathscr{A}\to\mathscr{B})=F$ 当且仅当 $v(\mathscr{A})=T$ 和 $v(\mathscr{A})=F$。</p></blockquote><blockquote><p><strong>Definition:</strong></p><p>$L$ 中的一个公式 $\mathscr{A}$ 是一个 <em>重言式</em>，如果对每个赋值 $v$，都有 $v(\mathscr{A})=T$。</p></blockquote><blockquote><p><strong>Proposition (Soundness，可靠性):</strong></p><p>$L$ 中的每个定理都是重言式。</p><p><strong>Proof:</strong>
数学归纳法。</p></blockquote><blockquote><p><strong>Proposition (Consistency, 一致性):</strong></p><p>$L$ 中的不存在公式 $\mathscr{A}$，使得 $\mathscr{A}$ 和 $(\sim\mathscr{A})$ 都是 $L$ 中的定理。</p><p><strong>Proof:</strong>
Soundness 可以推出 consistency。</p></blockquote><blockquote><p><strong>Proposition (Adequacy, 完备性):</strong></p><p>如果 $\mathscr{A}$ 是 $L$ 中的一个公式，且为重言式，那么 $\mathscr{A}$ 是 $L$ 中的一个定理。</p></blockquote><p>为了证明 adequacy，我们需要引入新的概念。</p><blockquote><p><strong>Definition:</strong></p><p>$L$ 的一个 <em>扩充 (extension)</em> 是一个形式系统，它通过修改或者扩大公理组使得原来所有的定理仍是定理（也可能引入新的定理）而得到。</p></blockquote><p>注意，此处说的是 <strong>修改</strong> 或 <strong>扩大</strong>，而并不仅仅是 <strong>扩大</strong>。 一个与 $L$ 没有共同公理的形式系统也可能是 $L$ 的一个扩充。</p><blockquote><p><strong>Proposition:</strong></p><p>$L$ 的一个扩充 $L^*$ 是一致的，当且仅当存在一个公式，它不是 $L^*$ 中的定理。</p><p><strong>Proof:</strong></p><p>(1) 如果 $L^*$ 一致，那么对任意公式 $\mathscr{A}$，总有 $\mathscr{A}$ 或 $(\sim\mathscr{A})$ 不是 $L^*$ 中的定理。</p><p>(2) 如果 $L^*$ 不一致，我们证明任意公式 $\mathscr{A}$ 都是 $L^*$ 中的定理。因为存在 $\mathscr{B}$，使得 $\mathscr{B}$ 和 $(\sim\mathscr{B})$ 都是 $L^*$ 中的定理。先前证过 $\vdash_L (\sim\mathscr{B}\to(\mathscr{B}\to\mathscr{A}))$，所以 $\vdash_{L^*} (\sim\mathscr{B}\to(\mathscr{B}\to\mathscr{A}))$。再应用两次 MP 即可得到 $\vdash_{L^*} \mathscr{A}$。</p></blockquote><blockquote><p><strong>Proposition:</strong></p><p>令 $L^*$ 是 $L$ 的一个一致的扩充，并且 $\mathscr{A}$ 是一个公式，它不是 $L^*$ 的一条定理，那么将 $L^*$ 补充公理 $(\sim\mathscr{A})$ 得到的系统 $L^{**}$ 也是一致的。</p><p><strong>Proof:</strong></p><p>如果 $L^{**}$ 不一致，那么 $\vdash_{L^{**}} \mathscr{A}$，即 $\{\sim\mathscr{A}\}\vdash_{L^*} \mathscr{A}$。</p><p>由 deduction theorem，$\vdash_{L^*} (\sim\mathscr{A}\to\mathscr{A})$。</p><p>先前有 $\vdash_L ((\sim\mathscr{A}\to\mathscr{A})\to\mathscr{A})$，故 $\vdash_{L^*} \mathscr{A}$。矛盾</p></blockquote><p>由此可知，我们可以依次考察所有公式 $\mathscr{A}$，将 $\mathscr{A}$ 或 $(\sim\mathscr{A})$ 加入公理组中，最终得到一个一致的形式系统，且有对于所有公式 $\mathscr{A}$，都有 $\mathscr{A}$ 或 $(\sim\mathscr{A})$ 是它的定理。</p><blockquote><p><strong>Definition:</strong></p><p>$L$ 的一个扩充是 <em>完全 (complete)</em> 的，如果对每个公式 $\mathscr{A}$，都有 $\mathscr{A}$ 或 $(\sim\mathscr{A})$ 是该扩充的一条定理。</p></blockquote><blockquote><p><strong>Proposition:</strong></p><p>存在一个 $L$ 的一致完全扩充。</p></blockquote><blockquote><p><strong>Proposition:</strong></p><p>如果 $L^*$ 是 $L$ 的一个一致完全扩充，那么存在一种赋值使得 $L^*$ 中的每个定理都取值 $T$。</p><p><strong>Proof:</strong></p><p>定义 $v(\mathscr{A})=T$，如果 $\mathscr{A}$ 是 $L^*$ 中的一条定理，反之定义 $v(\mathscr{A})=F$。用 valuation 的定义可以证明这样的函数是一个 valuation。</p></blockquote><blockquote><p><strong>Proof of the adequacy theorem of L:</strong></p><p>假设 $\mathscr{A}$ 是重言式，但不是 $L$ 的定理，那么可以扩充 $L$ 为 $L\cup\{\sim\mathscr{A}\}$ 再到一个一致完全扩充 $L^*$。$\vdash_{L^*}(\sim\mathscr{A})$，故必定存在赋值 $v$ 使得 $v(\sim\mathscr{A})=T$。矛盾。</p></blockquote></section><footer class=article-footer><section class=article-tags><a href=/tags/theory-of-computation/>Theory of Computation</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/theory-of-computation-lecture-4/><div class=article-image><img src=/p/theory-of-computation-lecture-4/cover.5a4cd64d97d6d054c8c5b7c90f52a40a_hu6720720966422977467.png width=250 height=150 loading=lazy alt="Featured image of post Theory of Computation Lecture 4" data-key=Theory-of-Computation-Lecture-4 data-hash="md5-WkzWTZfW0FTIxbfJD1KkCg=="></div><div class=article-details><h2 class=article-title>Theory of Computation Lecture 4</h2></div></a></article><article class=has-image><a href=/p/theory-of-computation-lecture-3/><div class=article-image><img src=/p/theory-of-computation-lecture-3/cover.5f5e9c4304a2514432b7282528d1e5b3_hu4880160208832955682.png width=250 height=150 loading=lazy alt="Featured image of post Theory of Computation Lecture 3" data-key=Theory-of-Computation-Lecture-3 data-hash="md5-X16cQwSiUUQytyglKNHlsw=="></div><div class=article-details><h2 class=article-title>Theory of Computation Lecture 3</h2></div></a></article><article class=has-image><a href=/p/theory-of-computation-lecture-2/><div class=article-image><img src=/p/theory-of-computation-lecture-2/cover.d961239af205931394d8a84ce64bd2a7_hu6011312951006749613.png width=250 height=150 loading=lazy alt="Featured image of post Theory of Computation Lecture 2" data-key=Theory-of-Computation-Lecture-2 data-hash="md5-2WEjmvIFkxOU2KhM5kvSpw=="></div><div class=article-details><h2 class=article-title>Theory of Computation Lecture 2</h2></div></a></article><article><a href=/p/drl-notes-6/><div class=article-details><h2 class=article-title>Deep Reinforcement Learning Lecture 6</h2></div></a></article><article><a href=/p/drl-notes-5/><div class=article-details><h2 class=article-title>Deep Reinforcement Learning Lecture 5</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=SUZ-tsinghua/SUZ-tsinghua.github.io issue-term=title crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2024 suz</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>